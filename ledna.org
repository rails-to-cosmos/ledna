#+CATEGORY: ledna
#+PROPERTY: header-args:emacs-lisp :tangle ledna.el

* Wrapper
#+BEGIN_SRC emacs-lisp
(defun ledna-dsl-init (&optional dsl)
  (let ((dsl (or dsl 'ledna)))
    (defvar ledna-dsl dsl "Language that edna uses for triggers and blockers.")
    (defvar ledna-dsl-trigger-handler "Org-edna custom trigger wrapper.")
    (defvar ledna-dsl-blocker-handler "Org-edna custom blocker wrapper.")

    (setq-default ledna-dsl dsl
                  ledna-dsl-trigger-handler (case dsl
                                              ('ledna #'ledna-trigger-function)
                                              ('emacs-lisp #'ledna-trigger-function-emacs-lisp))
                  ledna-dsl-blocker-handler (case dsl
                                              ('ledna #'ledna-blocker-function)
                                              ('emacs-lisp #'ledna-blocker-function-emacs-lisp)))

    (advice-add 'ledna-trigger-function :around #'ledna-dsl-specifier-trigger)
    (advice-add 'ledna-blocker-function :around #'ledna-dsl-specifier-blocker)))

(defun ledna-dsl-specifier-trigger (orig-fun &rest args)
  "Wrap edna's triggers.

ORIG-FUN is a trigger function called with ARGS."
  (apply ledna-dsl-trigger-handler args))

(defun ledna-dsl-specifier-blocker (orig-fun &rest args)
  "Wrap edna's blockers.

ORIG-FUN is a blocker function called with ARGS."
  (apply ledna-dsl-blocker-handler args))

(defun ledna-trigger-function-emacs-lisp (change-plist)
  "Trigger function work-horse.

See `emacs-edna-run' for CHANGE-PLIST explanation.

This shouldn't be run from outside of `org-trigger-hook'."
  (ledna-run change-plist
             (-when-let* ((form (org-entry-get (point) "TRIGGER" ledna-use-inheritance)))
               (eval (read form)))))

(defun ledna-blocker-function-emacs-lisp (change-plist)
  "Trigger function work-horse.

See `emacs-edna-run' for CHANGE-PLIST explanation.

This shouldn't be run from outside of `org-trigger-hook'."
  (ledna-run change-plist
             (if-let* ((form (org-entry-get pos "BLOCKER" ledna-use-inheritance)))
                 ;; Return nil if there is no blocking entry
                 (not (setq org-block-entry-blocking (eval (read form))))
               t)))
#+END_SRC
* Reports
#+BEGIN_SRC emacs-lisp
(defun ledna-price-counter (&optional target currency)
  (when-let (price (get-property "PRICE"))
    (inc-property "MONEY-SPENT" price (or currency "RUB") target)))

(defun ledna-time-counter (&optional target)
  (when-let (duration (get-property "DURATION"))
    (inc-property "TIME-SPENT" duration "hours" target)
    (inc-property "TIMES" 1 "times" target)))

(defun ledna-advanced-schedule (&optional target)
  (when-let (schedule-prop (get-property "SCHEDULE"))
    (let* ((schedule (cadr (read schedule-prop)))
           (next-time (get-nearest-date schedule)))
      (set-scheduled next-time target)
      (set-todo-state "TODO" target)
      (org-entry-put nil "LAST_REPEAT" (format-time-string
					      (org-time-stamp-format t t)
					      (current-time))))))

(defun ledna-money-time-report ()
  (when (string= (get-todo-state) "DONE")
    (ledna-time-counter)
    (ledna-price-counter))
  (ledna-advanced-schedule))

(defun ledna-touch (&optional target)
  (set-scheduled (active-timestamp "now") target)
  (set-todo-state "TODO" target))
#+END_SRC
* Utils
#+BEGIN_SRC emacs-lisp
(defun string-is-numeric-p (string)
  "Return non-nil if STRING is a valid numeric string.

Examples of valid numeric strings are \"1\", \"-3\", or \"123\"."
  ;; Can't use string-to-number, because it returns 0 if STRING isn't a
  ;; number, which is ambiguous.
  (numberp (car (read-from-string string))))
#+END_SRC
* Entry Manipulation
** Clone
#+BEGIN_SRC emacs-lisp
;; TODO: (ledna-clone (self)
;;        :state "TODO"
;;        :properties '(SCHEDULE TRIGGER)
;;        :insert-after (self))

(defun ledna-clone ()
  (let* ((props (org-entry-properties))
         (ignored-keys '("CLOSED" "TIMESTAMP_IA" "TODO" "FILE" "ITEM")))

    (org-insert-heading-respect-content)
    (insert (cdr (assoc-string "ITEM" props)))
    (set-todo-state "TODO")

    ;; clone properties
    (mapc #'(lambda (prop)
              (let ((key (car prop))
                    (val (cdr prop)))
                (when (not (-elem-indices key ignored-keys))
                  (org-set-property key val)))) props)

    ;; TODO: customize possibility
    (ledna-advanced-schedule)))
#+END_SRC
** Properties
#+BEGIN_SRC emacs-lisp
(defun set-property (property value &optional marker)
  (dolist (mark (or marker (self)))
    (org-entry-put
     mark property
     (cond ((numberp value) (number-to-string value))
           ((stringp value) value)
           (t "Unknown value type")))))

(defun get-property (property &optional marker default)
  (let ((mark (cond
               (marker
                (cond
                 ((listp marker) (car marker))
                 (t marker)))
          (t (car (self))))))
    (or (org-entry-get mark property)
        default)))

(defun inc-property (property &optional val units marker)
  (dolist (mark (or marker (self)))
    (let* ((full-prop-value (get-property property mark "0"))
           (inc-value (cond ((and (stringp val) (string-is-numeric-p val)) (string-to-number val))
                            ((numberp val) val)
                            (t 1)))
           (prop-number (string-to-number (car (split-string full-prop-value))))
           (prop-label (or units (key-description (cdr (split-string full-prop-value)))))
           (result-value (s-trim (concat (number-to-string (+ inc-value prop-number)) " " prop-label))))
      (set-property property result-value (list mark))
      result-value)))
#+END_SRC
** State
#+BEGIN_SRC emacs-lisp
(defun get-todo-state (&optional marker)
  (let ((mark (car (or marker (self)))))
    (save-excursion
      (with-current-buffer (marker-buffer mark)
        (goto-char mark)
        (substring-no-properties (org-get-todo-state))))))

(defun set-todo-state (state &optional marker)
  (let ((mark (car (or marker (self)))))
    (save-mark-and-excursion
      (with-current-buffer (marker-buffer mark)
        (goto-char mark)
        (org-todo state)))))
#+END_SRC
** Selectors
*** Self
#+BEGIN_SRC emacs-lisp
(defun self ()
  (save-excursion
    (goto-char (org-entry-beginning-position))
    (list (point-marker))))
#+END_SRC
*** Ids
#+BEGIN_SRC emacs-lisp
(defun ids (&rest ids)
  "Find a list of headings with given IDS.

Edna Syntax: ids(ID1 ID2 ...)

Each ID is a UUID as understood by `org-id-find'.

Note that in the edna syntax, the IDs don't need to be quoted."
  (mapcar (lambda (id) (org-id-find id 'marker)) ids))
#+END_SRC
*** Tags
#+BEGIN_SRC emacs-lisp
(defun tags (match-spec &optional scope skip)
  "Find entries using Org matching.

Edna Syntax: match(\"MATCH-SPEC\" SCOPE SKIP)

MATCH-SPEC may be any valid match string; it is passed straight
into `org-map-entries'.

SCOPE and SKIP are their counterparts in `org-map-entries'.
SCOPE defaults to agenda, and SKIP defaults to nil.

,* TODO Test
  :PROPERTIES:
  :BLOCKER:  match(\"test&mine\" agenda)
  :END:

\"Test\" will block until all entries tagged \"test\" and
\"mine\" in the agenda files are marked DONE."
  (setq scope (or scope 'agenda))
  (org-map-entries
   ;; Find all entries in the agenda files that match the given tag.
   (lambda nil (point-marker))
   match-spec scope skip))
#+END_SRC
*** Select
#+BEGIN_SRC emacs-lisp
(defun select (&rest markers)
  (apply #'append markers))
;; (select (ids "test-pass-purchased-p") (tags "test_tag"))
#+END_SRC
* Scheduling
#+BEGIN_SRC emacs-lisp
;; (set-keyword "SCHEDULED" (active-timestamp (get-nearest-date (cdr (read (get-property "SCHEDULE" (car (ids "test-event"))))))) (select (ids "test-event")))
;; (set-scheduled (get-nearest-date (cdr (read (get-property "SCHEDULE" (car (ids "test-event")))))) (select (ids "test-event")))
;; (active-timestamp (get-nearest-date (cadr (read (get-property "SCHEDULE" (car (ids "test-event")))))))
;; (get-nearest-date (list "Mon 09:00" "Mon 10:00" "Mon 12:00" "Mon 21:00" "Tue 17:00-18:00" "Thu 17:00-18:00" "Sat 13:00-14:00"))
;; (- (org-time-string-to-seconds (active-timestamp "Mon 09:00")) (time-to-seconds (org-current-time)))

(defun set-scheduled (timestamp &optional marker)
  (let ((mark (or marker (self))))
    (save-mark-and-excursion
     (cl-labels
      ((set-scheduled-on (mts)
                         (let ((pom (car mts)) (ts (cdr mts)))
                           (with-current-buffer
                               (marker-buffer pom)
                             (goto-char pom)
                             (org-add-planning-info 'scheduled ts)
                             ts))))
    (mapcar #'set-scheduled-on (-zip mark (-repeat (length mark) timestamp)))))))

(defun get-nearest-date (times)
  (cl-flet* ((diff (time)
                   (let* ((current-sec (time-to-seconds (org-current-time)))
                          (target-sec (org-time-string-to-seconds (active-timestamp time)))
                          (diff-sec (- target-sec current-sec)))
                     (cond ((and (> diff-sec 0) (< diff-sec 604800)) diff-sec)
                           ((< diff-sec 0) (+ diff-sec 604800))
                           ((> diff-sec 604800) (- diff-sec 604800)))))
             (comparator (a b) (< (diff a) (diff b))))
    (let ((nearest-date (car (sort times #'comparator))))
      nearest-date)))

(defun active-timestamp (str)
  (let* ((default-time (org-current-time))
         (decoded-time (decode-time default-time nil))
         (analyzed-time (org-read-date-analyze str default-time decoded-time))
         (encoded-time (apply #'encode-time analyzed-time)))
    (format-time-string (org-time-stamp-format t) encoded-time)))

(defun inactive-timestamp (str)
  (let* ((default-time (org-current-time))
         (decoded-time (decode-time default-time nil))
         (analyzed-time (org-read-date-analyze str default-time decoded-time))
         (encoded-time (apply #'encode-time analyzed-time)))
    (format-time-string (org-time-stamp-format t t) encoded-time)))
#+END_SRC
* COMMENT Local Variables
# Local Variables:
# firestarter: (org-babel-tangle)
# End:
